组件通信方式
面试必备

第一种.props
适用于：父传子组件，
如果传递的是函数，本质是子组件给父组件传递数据
如果传递的数据（非函数），本质就是父组件给子组件传递数据
书写方式三种
## 配置项props
    功能：让组件接收外部传过来的值
      （1）传递数据：
          <Demo name="xxx"/>
      （2）接收数据
          
          第一种方法（只接收）：
          props：['name']

          第二种方法（限制类型）：
          props：{
            name:String
          }

          第三种方法（限制类型、限制必要性、指定默认值）：
            props:{
              name:{
                  type:String,//类型
                  required:true,//必要性
                  default:'老王'//默认值
              }
            }
      备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，
      若业务需求确实需要修改，name请复制props的内容到data中一份，然后去修改data中的数据。(data里重新return ，储存一个新变量名储存值，然后后用methods或computed计算一下)
##
小提示：路由的props
书写形式：布尔值，对象，函数形式

第二种.自定义事件
适用于：子传父组件传值
$on与$emit
## 组件的自定义事件
  1.一种组件间通信的方式，适用于： 子组件==>父组件
  2.使用场景：A是父组件，B是子组件，B想给A传数据，name就要在A中给B绑定自定义事件（事件的回调在A中）
  3.绑定自定义事件：
        1.第一种方式，在父组件中<Demo @atguigu="test" /> 或 <Demo v-on:atguigu="test" />
        2.第二种方式
        <!-- 
            !<Demo ref="demo" />
            !......
            !mounted(){
              !this.$refs.xxx.$on('atguigu', this.test)
            !}
        
         -->
        3.若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法。
  4.触发自定义事件：this.$emit('atguigu', data)
  5.解绑自定义事件：this.$off('atguigu')
  6.组件上也可以绑定原生DOM事件，需要使用native修饰符。
  7.注意：通过this.$refs.xxx.$on('atguigu', options)绑定自定时事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会出现问题。
##

第三种.全局事件总线$bus
适用于：万能
Vue.prototype.$bus = this; 
## 全局事件总线（GlobalEventBus）
  1.一种组件间通信方式，适用于任意组件间通信。
  2.安装全局事件总线：
    <!-- 
    !new Vue({
      *......
      ?beforeCreate(){
          ?Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm
          !在vm create时给vue原型对象安装一个傀儡$bus（傀儡vm实例对象）
      ?}
      *.....
    *})
     -->
  3.使用事件总线：
    1）.接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身
    <!-- 
      ?methods(){
        ?demo(data){......}
      ?} 
      *.....
      ?mounted(){
        ?this.$bus.$on('事件名', this.demo)//或者直接把this.demo写成成回调函数形式
      ?}
     -->
     2）.提供数据：this.$bus.$emit('事件名', data)
  4.最好在beforeDestroy钩子中，用$off 去解绑当前组件所用到的事件。
##

第四种.pubsub-js,消息订阅与发布在react中使用比较多
适用于：万能，vue 中不用
## 消息订阅与发布（全局事件总线的封装库）
  1.一种组件间通信的方式，适用于任意组件间通信。
  2.使用步骤：
    1.安装pubsub： npm i pubsub-js
    2.引入： import pubsub from 'pubsub-js'
    3.订阅方接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的回调留在A组件自身
    <!-- 
      !method(){
        !demo(data){.....}
      !}
      ?.....
      *mounted(){
        *this.pid = pubsub.subscribe('xxx', this.demo)//订阅消息
      *}
     -->
     4.发布方提供数据：pubsub.publish('xxx', data)
     5.最好在beforeDestroy钩子中，用PubSub.unsubscribe(pid) 去取消订阅
##

第五种.vuex  
适用于：万能
## Vuex
  1.概念：在vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且使用以任意组件间通信。
  2.何时使用：多个组件需要共享数据时
  3.搭建vuex环境
  
      1.创建文件  src/store/index.js
    
<!-- !该文件用于创建Vuex中最为核心的store -->
<!-- !引入vue -->
import Vue from 'vue'
<!-- !引入Vuex -->
import Vuex from 'vuex'
<!-- !使用vuex插件 -->
Vue.use(Vuex)

<!-- !准备actions,用于响应组件中的动作 -->
const actions ={}
<!-- !准备mutations,用于操作数据（state） -->
const mutations ={}
<!-- !准备state,用于存储数据 -->
const state ={}


<!-- !创建并暴露store -->
export default new Vuex.Store({
    actions,
    mutations,
    state
})

      2.main.js中创建vm时传入store配置项
  import Vue from "vue";
  import App from './App.vue';
  Vue.config.productionTip = false;
  <!-- !引入store -->
  import store from './store/index'

  new Vue({
      el:"#app",
      render:(h)=> h(App),
      store,
      beforeCreate() {
          Vue.prototype.$bus = this
      },
  })

      4.基本使用，配置actions、配置mutations、操作文件store.js
1.  
<!-- !该文件用于创建Vuex中最为核心的store -->
<!-- !引入vue -->
import Vue from 'vue'
<!-- !引入Vuex -->
import Vuex from 'vuex'
<!-- !使用vuex插件 -->
Vue.use(Vuex)
<!-- !准备actions,用于响应组件中的动作 -->
const actions ={
    jia(context, value) {
        console.log('actions中的jia被调用');
        context.commit('JIA', value)
    }
}
<!-- !准备mutations,用于操作数据（state） -->
const mutations ={
    JIA(state, value){
        console.log('mutations中的JIA被调用');
        state.sum += value
    }
}
<!-- !准备state,用于存储数据 -->
const state ={
    sum:0 //当前的和
}

<!-- !创建并暴露store -->
export default new Vuex.Store({
    actions,
    mutations,
    state
})
<!-- !模板里不用写this,js脚本里写应该加this -->
2.组件中读取vuex中的数据：$store.state.sum
3.组件中修改vuex中的数据：$store.dispatch('actions中的方法名'， 数据)
或直接 $store.commite('mutations中的方法名', 数据)
若没有网络请求或其他业务逻辑，组件中也可以越过actions,即不写dispatch,直接编写commit

    4.getters的使用
      1.概念：当state中的数据需要经过加工再使用时，可以使用getters加工
      2.在store.js中追加getters配置
      3.组件中读取数据，$store.getters.bigSum

<!-- !准备getters，用于将state中的数据进行加工 -->
const getters ={
    bigSum(state){
        return state.sum*10
    }
}
<!-- !创建并暴露store -->
export default new Vuex.Store({
    actions,
    mutations,
    state,
    getters
})

      6.四个map方法的使用
        1.mapState:用于帮助我们映射state中的数据为计算属性
<!-- !借助mapMutations生成对应的方法，方法中会调用commit去联系mutations（数组写法） -->
computed:{
...mapMutations(['JIA', 'JIAN']),
}
<!-- !借助mapMutations生成对应的方法，方法中会调用commit去联系mutations（对象写法） -->
computed:{
...mapMutations({increase:'JIA', decrease:'JIAN'}),
}
 
        2.mapGetters方法：用于帮助我们映射getters中的数据为计算属性
<!-- !借助mapStae生成计算属性，从state中读取数据。（对象写法） -->
computed:{
...mapGetters({bigSum:'bigsum'})
}
<!-- !借助mapState生成计算属性，从state中读取数据。（数组写法） -->
computed:{
...mapGetters(['bigSum'])
}

        3.mapActions方法：用于帮助我们生成与actions对话的方法，即：包含$store.dispatch(xxx)的函数
<!-- !借助mapMutations生成对应的方法，方法中会调用diapatch去联系actions（数组写法） -->
methods:{
...mapActions(['jiaOdd', 'jiaWait']),
}
<!-- !借助mapMutations生成对应的方法，方法中会调用diapatch去联系actions（对象写法） -->
methods:{
...mapActions({increaseOdd:'jiaOdd', increaseWait:'jiaWait'})
}

      7.模块化+命名空间
        1.目的：让代码更好维护，让多种数据分类更加明确。
        2.修改store.js(inde.js)

<!-- !求和相关的配置 -->
const countAbout = {
    <!-- *开启命名空间，以区分不同组件 -->
    namespaced:true,
    state: { x:1 },
    actions: { ... },
    mutations: { ... },
    getters: {
        bigSum(state) {
            return state.sum * 10
        }
    }
}
<!-- !人员管理相关的配置 -->
const personAbout = {
    <!-- *开启命名空间，以区分不同组件 -->
    namespaced:true,
    state: { x:1 },
    actions: { ... },
    mutations: { ... },
}
<!-- !创建并(暴露)store -->
const store =  new Vuex.Store({
    modules:{
        countAbout:countOptions,
        personAbout:personOptions
    }
})

        3.开启命名空间后，组件中读取state数据（这里直接去案例里看具体写法）Count.vue里用了map方式，Person.vue用了纯自己写的
  <!-- *方式一、自己直接读取 -->
  return this.$store.state.personAbout.personList 
  <!-- *方式二、借助mapState读取 -->
  ...mapState('countAbout', ['sum', 'school', 'subject']),

        4.开启命名空间后，组件中读取getters数据
  <!-- *方式一、组件直接读取 -->
  return this.$store.getters['personAbout/firstPersonName']
  <!-- *方式二、借助mapGetters读取 -->
  ...mapGetters('countAbout', ['bigSum'])

        5.开启命名空间后，组件中调用dispatch数据
  <!-- *方式一、组件直接读取 -->
  this.$store.dispatch('personAbout/addPersonWang', personObj)
  <!-- *方式二、借助mapGetters读取 -->
  ...mapActions('countAbout', {increaseOdd:'jiaOdd', increaseWait:'jiaWait'})

        6.开启命名空间后，组件中调用commit
  <!-- *方式一、组件直接读取 -->
  this.$store.commit('personAbout/ADD_PERSON', personObj)
  <!-- *方式二、借助mapGetters读取 -->
  ...mapMutations('countAbout', {increase:'JIA', decrease:'JIAN'}),
##

第六种.插槽
适用于：父子组件通信（一般结构）
## 插槽
    1.作用：让父组件向子组件指定位置插入html结构，也是一种组件间通信的方式，使用于父组件 ===> 子组件（props反向配置）
    2.分类：默认插槽、具名插槽、作用域插槽
    3.使用方式
          1.默认插槽
            父组件
                  <Category>
                    <div>html结构</div>
                  </Category>
            子组件
                  <template>
                    <div>
                      <!-- 定义插槽 -->
                        <slot>插槽默认内容</slot>
                    </div>
                  </template>
           2.具名插槽
             父组件
                  <Category slot="center">
                      <div>html结构1</div>
                  </Category>
                  <Category v-slot:footer>
                      <div>html结构2</div>
                  </Category>
            子组件
                  <template>
                    <div>
                      <!-- 定义插槽 -->
                        <slot name="center">插槽默认内容...</slot>
                        <slot name="footer">插槽默认内容...</slot>
                    </div>
                  </template>
            3.作用域插槽
                1.理解：数据在组件自身，但根据数据生成的结构需要的组件的使用者来决定。（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）
                2.具体编码：

  <!-- 父组件 -->
  <Category>
      <template scope="scopeData">
        <!-- 生成ul列表 -->
        <ul>
          <li v-for="(g, index) in scopeData.games" :key="index">{{g}}</li>
        </ul>
      </template>
  </Category>

  <Category>
      <template slot-scope="scopeData">
        <!-- 生成h4标题 -->
        <h4 v-for="(g, index) in scopeData.games" :key="index">{{g}}</h4>
      </template>
  </Category>

<!-- 子组件 -->
<template>
  <div>
    <slot :games="games">我是默认的</slot>
  </div>
</template>

<script>
  export default {
    name:"Category",
    props:['title'],
    data() {
    return {
      games: ["红色警戒", "穿越火线", "劲舞团", "超级玛丽"],
    };
  },

  }
</script>
##

2022.2.16 新学习通信方式
## 1事件的注意事项
事件：系统事件 click,双击，鼠标系列
      自定义事件

事件源、事件类型、事件回调

1.原生DOM---button可以绑定系统事件   click单击双击事件
2.组件标签---event可以绑定系统事件（不起作用：因为属性自定义事件）@click.native修改为原生DOM事件

## 2.v-model【组件通信方式】
v-model 它是Vue框架中的指令，它主要结合表单元素一起使用（文本框、复选、单选）
主要作用是收集表单数据

v-model 实现原理：value与input事件时间，而且还需要注意可以通过v-model实现父子组件数据同步

## 3.属性修饰符sync【组件通信方式一种】
可以实现父子组件数据同步

:money.sync,代表父组件给子组件传递props【money】 给当前子组件绑定了一个自定义事件（update:money）

## 4.$listeners与$attrs
他们两者是组件组件实例的属性，可以获取到父组件给子组件传递的props与自定义事件

